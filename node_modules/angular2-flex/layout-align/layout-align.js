var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { NgModule } from '@angular/core';
import { BREAKPOINTS, WHITESPACE, AttributeDirectiveFactory } from '../core';
var ALIGNMENT_MAIN_AXIS = [
    '',
    'start',
    'center',
    'end',
    'stretch',
    'space-around',
    'space-between'
];
var ALIGNMENT_CROSS_AXIS = [
    '',
    'start',
    'center',
    'end',
    'stretch'
];
function extractAlignAxis(attrValue) {
    if (attrValue === void 0) { attrValue = ''; }
    var axis = {
        main: 'start',
        cross: 'stretch'
    };
    var values;
    if (attrValue.indexOf('-') === 0 || attrValue.indexOf(' ') === 0) {
        // For missing main-axis values
        attrValue = "none" + attrValue;
    }
    values = attrValue.toLowerCase().trim().replace(WHITESPACE, '-').split('-');
    if (values.length && (values[0] === 'space')) {
        // for main-axis values of 'space-around' or 'space-between'
        values = [(values[0] + "-" + values[1]), values[2]];
    }
    if (values.length > 0) {
        axis.main = values[0] || axis.main;
    }
    if (values.length > 1) {
        axis.cross = values[1] || axis.cross;
    }
    if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0) {
        axis.main = 'start';
    }
    if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0) {
        axis.cross = 'stretch';
    }
    return axis;
}
function getValue(value) {
    var attributeValue = value;
    var axis = extractAlignAxis(attributeValue);
    attributeValue = axis.main + "-" + axis.cross;
    return attributeValue;
}
var directives = [];
var generator = new AttributeDirectiveFactory();
BREAKPOINTS.forEach(function (breakPoint) {
    var name = breakPoint ? "layout-align-" + breakPoint : 'layout-align';
    directives.push(generator.generateDirective(name, breakPoint, getValue));
});
export var LayoutAlignModule = (function () {
    function LayoutAlignModule() {
    }
    LayoutAlignModule.forRoot = function () {
        return {
            ngModule: LayoutAlignModule,
            providers: []
        };
    };
    LayoutAlignModule = __decorate([
        NgModule({
            declarations: directives.slice(),
            imports: [],
            exports: directives.slice(),
        }), 
        __metadata('design:paramtypes', [])
    ], LayoutAlignModule);
    return LayoutAlignModule;
}());

//# sourceMappingURL=layout-align.js.map
